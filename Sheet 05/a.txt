//{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
// 	"1": {
// 		"prefix": "cpp",
// 		"body": [
// 		  "#include<bits/stdc++.h>",
// 		  "using namespace std;",
// 		  "int main()",
// 		  "{",
// 		  "		$0",
// 		  "    return 0;",
// 		  "}"
// 		],
// 		"description": ""
// 	  }
// 
//}

{
	"1": {
		"prefix": "cpp",
		"body": [
			"#include<bits/stdc++.h>",
			"#include<ext/pb_ds/assoc_container.hpp>",
			"#include<ext/pb_ds/tree_policy.hpp>",
		    "#define ll long long",
			"#define pi pair<ll, ll>",
			"#define asort(v) sort(v.begin(), v.end())",
			"#define rsort(v) sort(v.begin(), v.end(), greater<>())",
			"#define yes cout << \"YES\\n\"",
			"#define no cout << \"NO\\n\"",
			"#define cyes cout << \"Yes\\n\"",
			"#define cno cout << \"No\\n\"",
			"#define endl \"\\n\"",
			"#define fast() ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)",
			"using namespace __gnu_pbds;",
			"using namespace std;",
			"",
			"template <typename T> using pbds = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"",
			"",
			"void solve()",
			"{",
			"    $0",
			"}",
			"",
			"",
			"int main()",
			"{",
			"    fast();",
			"    int t=1;",
			"    while (t--) {",
			"        solve();",
			"    }",
			"",
			"    return 0;",
			"",
			"",
			"// Alhamdulillah",
			"}"
		],
		"description": "Basic C++ main function setup"
	},
	 

	"2": {
 		"prefix": "cnode",
  		"body": [
		"class Node",
		"{",
		"    public:",
		"        int val;",
		"        Node* next;",
		"    Node(int val)",
		"    {",
		"        this->val = val;",
		"        this->next = NULL;",
		"    }",
		"};"
	],
	"description": "Linked list node create"
	},




	"3": {
	"prefix": "snode",
	"body": [
		"#include <bits/stdc++.h>",
		"using namespace std;",
		"class Node",
		"{",
		"public:",
		"    int val;",
		"    Node *next;",
		"    Node(int val)",
		"    {",
		"        this->val = val;",
		"        this->next = NULL;",
		"    }",
		"};",
		"void insert_tail(Node *&head, Node *&tail, int val)",
		"{",
		"    Node *newNode = new Node(val);",
		"    if (head == NULL)",
		"    {",
		"        head = newNode;",
		"        tail = newNode;",
		"        return;",
		"    }",
		"    tail->next = newNode;",
		"    tail = newNode;",
		"}",
		"void print_linked_list(Node *head)",
		"{",
		"    Node *tmp = head;",
		"    while (tmp != NULL)",
		"    {",
		"        cout << tmp->val << \" \";",
		"        tmp = tmp->next;",
		"    }",
		"    cout << endl;",
		"}",
		"int main()",
		"{",
		"    Node *head = NULL;",
		"    Node *tail = NULL;",
		"    int val;",
		"    while (true)",
		"    {",
		"        cin >> val;",
		"        if (val == -1)",
		"            break;",
		"        insert_tail(head, tail, val);",
		"    }",
		"    print_linked_list(head);",
		"    return 0;",
		"}"
	],
	"description": "Singly linked list Input & output"
	},




	"4": {
	"prefix": "dnode",
	"body": [
		"#include<bits/stdc++.h>",
		"using namespace std;",
		"class Node",
		"{",
		"    public:",
		"        int val;",
		"        Node* next;",
		"        Node* prev;",
		"    Node(int val)",
		"    {",
		"        this->val = val;",
		"        this->next = NULL;",
		"        this->prev = NULL;",
		"    }",
		"};",
		"",
		"void insert_tail(Node *&head, Node *&tail, int val){",
		"    Node *newNode = new Node(val);",
		"    if(head==NULL){",
		"        head = newNode;",
		"        tail = newNode;",
		"        return;",
		"    }",
		"    tail->next = newNode;",
		"    newNode->prev = tail;",
		"    tail = tail->next;",
		"}",
		"",
		"",
		"int size_doubly(Node *head){",
		"    Node *tmp = head;",
		"    int count = 0; ",
		"    while (tmp != NULL)",
		"    {",
		"        count++;",
		"        tmp = tmp->next;",
		"    }",
		"    return count;",
		"    ",
		"}",
		"void print(Node *head){",
		"    Node *tmp = head;",
		"    while (tmp != NULL)",
		"    {",
		"        cout << tmp->val<<\" \";",
		"        tmp = tmp->next;",
		"    }",
		"    cout << endl;",
		"    ",
		"}",
		"int main()",
		"{",
		"",
		"",
		"    Node *head = NULL;",
		"    Node *tail = NULL;",
		"    int val;",
		"    while (true)",
		"    {",
		"        cin >> val; ",
		"        if(val == -1) break;",
		"        insert_tail(head, tail, val);",
		"",
		"    }",
		"    print(head);",
		"",
		"    return 0;",
		"}"
	],
	"description": "doubly linked list input and output"
	},



	"5": {
	"prefix": "bnode",
	"body": [
		"class Node ",
		"{",
		"    public:",
		"        int val;",
		"        Node *left;",
		"        Node *right;",
		"    Node(int val)",
		"    {",
		"        this->val = val;",
		"        this->left = NULL;",
		"        this->right = NULL;",
		"    }",
		"};"
	],
	"description": "create a binary node"
	},


	"6": {
	"prefix": "tree",
	"body": [
		"Node* input_tree()",
		"{",
		"    int val; cin >> val;",
		"    Node *root;",
		"    if(val == -1) root = NULL;",
		"    else root = new Node(val);",
		"",
		"    queue<Node* > q;",
		"    if(root) q.push(root);",
		"",
		"    while (!q.empty())",
		"    {",
		"        // 1st step; ",
		"        Node* p = q.front();",
		"        q.pop();",
		"",
		"        // 2nd step;",
		"        int l, r;",
		"        cin >> l >> r;",
		"        Node* myLeft;",
		"        Node* myRight;",
		"        if(l==-1) myLeft = NULL;",
		"        else myLeft = new Node(l);",
		"        if(r==-1) myRight = NULL;",
		"        else myRight = new Node(r);",
		"",
		"        p->left = myLeft;",
		"        p->right = myRight;",
		"",
		"        // 3rd step:",
		"        if(p->left) q.push(p->left);",
		"        if(p->right) q.push(p->right);",
		"    }",
		"    return root; ",
		"}"
	],
	"description": ""
	},



	"7": {
	"prefix": "level",
	"body": [
		"void level_order(Node* root)",
		"{",
		"    if(root == NULL) {",
		"        cout << \"Tree nai\" <<endl;",
		"        return;",
		"    }",
		"    queue<Node *> q;",
		"    q.push(root);",
		"",
		"    while (!q.empty())",
		"    {",
		"        Node* f = q.front();",
		"        q.pop();",
		"",
		"        cout << f->val << \" \";",
		"",
		"        if(f->left) q.push(f->left);",
		"        if(f->right) q.push(f->right);",
		"    }  ",
		"}"
	],
	"description": ""
	},




"Custom Header": {
    "prefix": "istiak",
    "body": [
        "/*",
        " * Bismillahir Rahmanir Raheem",
        " *",
        " * * * * Coder   : abubakaristiak",
        " * * * * Created : ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} || ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}",
        " * * * * File    : ${TM_FILENAME}",
        "*/"
    ],
    "description": "Custom header with user info, creation date, and file name"
}



}

